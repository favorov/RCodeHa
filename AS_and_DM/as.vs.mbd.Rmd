---
title: "Comparing AS junctions and MBD methylation for ACC data"
author: "Alexander Favorov"
output: 
 html_document:
  toc: false

---

<!-- cache is off, we save all the neccessary things in Rda -->
```{r init, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE,message=FALSE,cache=FALSE,warning=FALSE,error=FALSE)
options(width=110)
```

`r format(Sys.Date(), "%d %b %Y")` 

```{r prepare }
source('prepare.meth.data.for.as.junctions.R')
mbd.sample.ids<-colnames(mbd.as.junction.coverage)
rna.sample.ids<-names(mcols(as.junction.ranges))

tests.number<-dim(mbd.as.junction.coverage)[1]

```

# Is there any DM signal on the AS junctions?
### Here, we omit the ranks of the AS junctions
```{r DM in AS junctions}

fisher.mbd.in.as.result.loaded<-FALSE
if ('fisher.mbd.in.as.result' %in% ls() &&
class(fisher.mbd.in.as.result)=='data.frame')
fisher.mbd.in.as.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! fisher.mbd.in.as.result.loaded) && 
	file.exists('fisher.mbd.in.as.result.Rda') &&
	'fisher.mbd.in.as.result' %in% load('fisher.mbd.in.as.result.Rda') &&
	class(fisher.mbd.in.as.result)=='data.frame')
{
	message('Fisher result loaded...')
	fisher.mbd.in.as.result.loaded<-TRUE
}

if(!fisher.mbd.in.as.result.loaded)
{
	mbd.contrast<-logical(length(mbd.sample.ids))
	mbd.contrast[grep('HN',mbd.sample.ids)]<-TRUE

	mbd.norm.no<-length(which(!mbd.contrast))
	mbd.tumor.no<-length(which(mbd.contrast))

	fishtabs<-as.matrix(prepare.tabulated.fisher(mbd.tumor.no,mbd.norm.no))
	#prepare Fisher table

	message('create result matrix')

	fisher.mbd.in.as.result.mat<-matrix(fishtabs[1,],ncol=6,nrow=tests.number,byrow=TRUE)

	colnames(fisher.mbd.in.as.result.mat)<-
			c('fisher.p.values','meth.in.normals.ratio','meth.in.tumors.ratio','OR','CI_95_L','CI_95_H') 

	revcontrast<-!mbd.contrast
	report.every<-tests.number %/% 100
	message('fill result matrix')
	for (rown in 1:tests.number) 	
	{
		if (!(rown %% report.every)) message(rown)
		theraw<-mbd.as.junction.coverage[rown,]
		aslogic<-as.logical(theraw)
		MY<-sum(aslogic & mbd.contrast)
		MN<-sum(aslogic & revcontrast)
		if (0==MN && 0==MY) next
		fishres<-fishtabs[tab.fisher.row.no(mbd.tumor.no,mbd.norm.no,MY,MN),]
		fisher.mbd.in.as.result.mat[rown,]<-fishres
	}
	message('converting to dataframe')
	fisher.mbd.in.as.result<-as.data.frame(fisher.mbd.in.as.result.mat)
	save(file='fisher.mbd.in.as.result.Rda',list=c('fisher.mbd.in.as.result'))

	message('done\n')
}

```
The first test is quite simple. We take all the AS junctions and we perform exact Fisher test (Tumor,Normal)x(MBD signal presebce) for each of them. Then, we apply Bonferroni correction for number of AS junctions.
```{r mbd.reliable, echo=TRUE}
dm.reliable<-p.adjust(fisher.mbd.in.as.result[,1],method="bonferroni")<.05
dm.reliable.report<-fisher.mbd.in.as.result[dm.reliable,]
rownames(dm.reliable.report)<-names(as.junction.ranges)[dm.reliable]
dm.reliable.report[,1:3]
```

Here is the list of the genes (for reference)
```{r genes list DM, echo=TRUE}
cat(unique(sapply(strsplit(names(as.junction.ranges[dm.reliable]),'.',fixed = TRUE),'[',1)))

```

DM regions are coordinated in the same gene. The difference can be in any direction.

# Are there any AS regions with rank that corresponds to the MBD signal presence locally?
### Here, we omit T/N classification

We take junctions, one-by-one and test whether the methylation signal discriminate ranks by Wilcoxon test.
First, we define the common set of samples in MBD and RNA.
```{r common samples, echo=TRUE}
mbd.to.rna.match <- match(mbd.sample.ids,rna.sample.ids)
does.mdb.has.match <- !is.na(mbd.to.rna.match)
mbd.sample.ids[does.mdb.has.match]
```
So, `r sum(does.mdb.has.match)` samples are common for `r length(mbd.sample.ids)` MBD samples and `r length(rna.sample.ids)` RNA samples.

```{r calculate selfreg mbd to as rank}
wilcoxon.as.local.reg.by.mbd.result.loaded<-FALSE
if ('wilcoxon.as.local.reg.by.mbd.result' %in% ls() &&
class(wilcoxon.as.local.reg.by.mbd.result)=='data.frame')
wilcoxon.as.local.reg.by.mbd.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! wilcoxon.as.local.reg.by.mbd.result.loaded) && 
	file.exists('wilcoxon.as.local.reg.by.mbd.result.Rda') &&
	'wilcoxon.as.local.reg.by.mbd.result' %in% load('wilcoxon.as.local.reg.by.mbd.result.Rda') &&
	class(wilcoxon.as.local.reg.by.mbd.result)=='data.frame')
{
	message('result loaded...')
	wilcoxon.as.local.reg.by.mbd.result.loaded<-TRUE
}

if(!wilcoxon.as.local.reg.by.mbd.result.loaded)
{
	message('create result matrix')

	wilcoxon.as.local.reg.by.mbd.result.mat<-matrix(c(1,0,0),nrow=tests.number,ncol=3,byrow=TRUE)

	colnames(wilcoxon.as.local.reg.by.mbd.result.mat)<-
			c('p.value','obs inv#','exp inv#') 
	
	report.every<-tests.number %/% 100
	message('fill result matrix')
	for (rown in 1:tests.number) 	
	{
		if (!(rown %% report.every)) message(rown)
		is.meth<-as.logical(mbd.as.junction.coverage[rown,does.mdb.has.match])
		if(!sum(is.meth) || !sum(!is.meth)) next
		ranks<-unlist(mcols(as.junction.ranges)[rown,mbd.to.rna.match[does.mdb.has.match]])
		wilc<-wilcox.test(jitter(ranks,factor=0.001)~!(is.meth))
		if(is.na(wilc$p.value)) next
		wilcoxon.as.local.reg.by.mbd.result.mat[rown,1]<-wilc$p.value	
		wilcoxon.as.local.reg.by.mbd.result.mat[rown,2]<-wilc$statistic
		wilcoxon.as.local.reg.by.mbd.result.mat[rown,3]<-(sum(is.meth)*sum(!is.meth))/2
	}
	message('converting to dataframe')
	wilcoxon.as.local.reg.by.mbd.result<-as.data.frame(wilcoxon.as.local.reg.by.mbd.result.mat)
	save(file='wilcoxon.as.local.reg.by.mbd.result.Rda',list=c('wilcoxon.as.local.reg.by.mbd.result'))

	message('done\n')
}

as.by.mbd.selfreg.reliable.pval<-wilcoxon.as.local.reg.by.mbd.result$p.value
```
Let's look what we have. The minimal p-value for the self-regulation is `r min(as.by.mbd.selfreg.reliable.pval)`. There are `r sum(p.adjust(as.by.mbd.selfreg.reliable.pval,method="bonferroni")<0.05)` p-calues passed Bofferromi for # of tests (junctions). There are `r sum(p.adjust(as.by.mbd.selfreg.reliable.pval,method="BH")<0.1)` passed Benjamini-Hoochberg with q-value<0.1 .

And, the best selr-reg junctions (uncorrected p < 0.00005 looks good, but it is killed by Bonferroni) are:
```{r best selfreg, echo=TRUE}
names(as.junction.ranges)[which(p.adjust(as.by.mbd.selfreg.reliable.pval,method="none")<0.00005)]
```

# Are there any AS regions with rank that corresponds to the _cis_ MBD signal presence?
### Here, we omit T/N classification. 

Actually, we do the same as in prevuious story, but we look not only for same-junction regulation (self-regulation) but for all same-gene junctions.

###Wilcoxon test

```{r prepare wilcoxon cisregulation}

genes<-unique(sapply(strsplit(names(as.junction.ranges),'.',fixed = TRUE),'[',1))

wilcoxon.as.cis.reg.by.mbd.result.loaded<-FALSE
if ('wilcoxon.as.cis.reg.by.mbd.result' %in% ls() &&
class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! wilcoxon.as.cis.reg.by.mbd.result.loaded) && 
	file.exists('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	'wilcoxon.as.cis.reg.by.mbd.result' %in% load('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
{
	message('wilcoxon cis result loaded...')
	wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
}

if(!wilcoxon.as.cis.reg.by.mbd.result.loaded)
{
	message('create wicloxon cis result matrix')

	wilcoxon.as.cis.reg.by.mbd.result.mat<-matrix(nrow=0,ncol=3)

	colnames(wilcoxon.as.cis.reg.by.mbd.result.mat)<-
			c('p.value','obs inv#','exp inv#') 
	
	message('fill cis result matrix')
	for (gene in genes)
	{
		#if(!gene==genes[2]) next
		#testing mode
		message(gene)
		the.gene.junctions<-grep(gene,names(as.junction.ranges))
		l<-length(the.gene.junctions)
		the.gene.result.mat<-matrix(c(1,0,0),nrow=l^2,ncol=3,byrow=TRUE)
		colnames(the.gene.result.mat)<-c('p.value','obs inv#','exp inv#') 
		for (i in 1:l)
		{
			is.meth<-as.logical(mbd.as.junction.coverage[the.gene.junctions[i],does.mdb.has.match])
			if(!sum(is.meth) || !sum(!is.meth)) next
			for (k in 1:l) 	
			{
				index<-(i-1)*l+k
				ranks<-unlist(mcols(as.junction.ranges)[the.gene.junctions[k],mbd.to.rna.match[does.mdb.has.match]])
				wilc<-wilcox.test(jitter(ranks,factor=0.001)~!(is.meth))
				if(is.na(wilc$p.value)) next
				the.gene.result.mat[index,1]<-wilc$p.value	
				the.gene.result.mat[index,2]<-wilc$statistic
				the.gene.result.mat[index,3]<-(sum(is.meth)*sum(!is.meth))/2
			}
		}
		#in expand.grid, the second var is outer (slow), so first is k (as)
		rownames(the.gene.result.mat)<-
			apply(expand.grid(names(as.junction.ranges)[the.gene.junctions],names(as.junction.ranges)[the.gene.junctions]),1,
				function(pair) paste0('as@',pair[1],'~dm@',pair[2]))
		wilcoxon.as.cis.reg.by.mbd.result.mat<-rbind(wilcoxon.as.cis.reg.by.mbd.result.mat,the.gene.result.mat)
	}
message('converting to dataframe')
	wilcoxon.as.cis.reg.by.mbd.result<-as.data.frame(wilcoxon.as.cis.reg.by.mbd.result.mat)
	save(file='wilcoxon.as.cis.reg.by.mbd.result.Rda',list=c('wilcoxon.as.cis.reg.by.mbd.result'))

	message('done\n')
}


```

Here is the table for all _cis_ juntion-interations that have Wilcoxon pass FDR 5%

```{r table cis wilcoxon fdr 5%, echo=FALSE}

if ( sum(p.adjust(wilcoxon.as.cis.reg.by.mbd.result$p.value,method = 'BH')<0.05)>0 )
{
	fdr5.cis.res<-wilcoxon.as.cis.reg.by.mbd.result[which(p.adjust(wilcoxon.as.cis.reg.by.mbd.result$p.value,method = 'BH')<0.05),]
	names.fdr5.cis.res<-unlist(strsplit(rownames(fdr5.cis.res),"[@.~]"))
	#as@FAT1.chr4:187539578-187630378~dm@FAT1.chr4:187519279-187521052
	annot.fdr5.cis.res<-data.frame(
		gene=names.fdr5.cis.res[seq(2,length(names.fdr5.cis.res),6)],
		alt.splice.region=names.fdr5.cis.res[seq(3,length(names.fdr5.cis.res),6)],
		diff.met.region=names.fdr5.cis.res[seq(6,length(names.fdr5.cis.res),6)]
	)
	rownames(fdr5.cis.res)=NULL
	fdr5.cis.res.with.annot<-cbind(annot.fdr5.cis.res,fdr5.cis.res)
	fdr5.cis.res.with.annot
} else print('..empty..')
```

Again, let's look at gene with wilcoxon p.value<1e-6

```{r table wilcoxon cis p<1e-6}
wilcoxon.as.cis.reg.by.mbd.result[wilcoxon.as.cis.reg.by.mbd.result$p.value < 1e-6,]

```
###Kendall rank correlation: junction-to-junction is the same gene

We test Kendall correlation between junction A's rank in splicing and junction B's methylation, juctions pairs are from the same gene from the diff-AS list. 

```{r prepare kendall cisregulation}

genes<-unique(sapply(strsplit(names(as.junction.ranges),'.',fixed = TRUE),'[',1))

kendall.as.cis.reg.by.mbd.result.loaded<-FALSE
if ('kendall.as.cis.reg.by.mbd.result' %in% ls() &&
class(kendall.as.cis.reg.by.mbd.result)=='data.frame')
kendall.as.cis.reg.by.mbd.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! kendall.as.cis.reg.by.mbd.result.loaded) && 
	file.exists('kendall.as.cis.reg.by.mbd.result.Rda') &&
	'kendall.as.cis.reg.by.mbd.result' %in% load('kendall.as.cis.reg.by.mbd.result.Rda') &&
	class(kendall.as.cis.reg.by.mbd.result)=='data.frame')
{
	message('kendall cis result loaded...')
	kendall.as.cis.reg.by.mbd.result.loaded<-TRUE
}

if(!kendall.as.cis.reg.by.mbd.result.loaded)
{
	message('create kendall cis result matrix')

	kendall.as.cis.reg.by.mbd.result.mat<-matrix(nrow=0,ncol=2)

	colnames(kendall.as.cis.reg.by.mbd.result.mat)<-
			c('p.value','tau') 
	
	message('fill cis kendall result matrix')
	for (gene in genes)
	{
		#if(!gene==genes[2]) next
		#testing mode
		message(gene)
		the.gene.junctions<-grep(gene,names(as.junction.ranges))
		l<-length(the.gene.junctions)
		the.gene.result.mat<-matrix(c(1,0),nrow=l^2,ncol=2,byrow=TRUE)
		colnames(the.gene.result.mat)<-c('p.value','tau') 
		for (i in 1:l)
		{
			meth<-mbd.as.junction.coverage[the.gene.junctions[i],does.mdb.has.match]
			#if(var(meth)==0) next
			for (k in 1:l) 	
			{
				index<-(i-1)*l+k
				ranks<-unlist(mcols(as.junction.ranges)[the.gene.junctions[k],mbd.to.rna.match[does.mdb.has.match]])
				#if(var(ranks)==0) next
				ken<-cor.test(jitter(ranks,factor = 0.00001),jitter(meth,factor = 0.00001),method='kendall')
				#ken<-cor.test(meth,ranks,method = 'kendall')
				if(is.na(ken$p.value)) next
				the.gene.result.mat[index,1]<-ken$p.value	
				the.gene.result.mat[index,2]<-ken$estimate[[1]] #tau
			}
		}
		#in expand.grid, the second var is outer (slow), so first is k (as)
		rownames(the.gene.result.mat)<-
			apply(expand.grid(names(as.junction.ranges)[the.gene.junctions],names(as.junction.ranges)[the.gene.junctions]),1,
				function(pair) paste0('as@',pair[1],'~dm@',pair[2]))
		kendall.as.cis.reg.by.mbd.result.mat<-rbind(kendall.as.cis.reg.by.mbd.result.mat,the.gene.result.mat)
	}
	message('converting to dataframe')
	kendall.as.cis.reg.by.mbd.result<-as.data.frame(kendall.as.cis.reg.by.mbd.result.mat)
	save(file='kendall.as.cis.reg.by.mbd.result.Rda',list=c('kendall.as.cis.reg.by.mbd.result'))

	message('done\n')
}


```

Here is the list of the genes that carry pairs of junctions with $AS(Junction1)$ ~ $Meth(Junction2)$. We do not tell $Junction1$ == $Junction2$ from $Junction1$ != $Junction2$.

```{r genes list AS vs M, echo=FALSE}

cat(
	unique(
		sapply(
			strsplit(
				sapply(
					strsplit(
						rownames(kendall.as.cis.reg.by.mbd.result)[
							which(
								p.adjust(kendall.as.cis.reg.by.mbd.result$p.value,method = 'BH')<0.05)
						],
						'@',fixed=TRUE
					),"[",2
				),".",fixed=TRUE
			),"[",1
		)
	)
)

```

### Kendall rank correlation: junction-rank-to-a-noodle-MBD is the same gene. Noodle is in a `r width(as.genes.noodles.ranges)[1]` region in or near the gene

```{r prepare kendall cisregulation noodles}

# new magic name: kendall.as.cis.reg.by.noodle.mbd.result

#genes<-unique(sapply(strsplit(names(as.junction.ranges),'.',fixed = TRUE),'[',1))
#the gene names as given by junction data, so if the names changed in new list, it will be
#named as new(old) in as.genes.noodles.ranges and the neme in genes now is old

#mow, it is as.genes.symbols

wilcoxon.as.cis.reg.by.mbd.result.loaded<-FALSE
if ('wilcoxon.as.cis.reg.by.mbd.result' %in% ls() &&
class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! wilcoxon.as.cis.reg.by.mbd.result.loaded) && 
	file.exists('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	'wilcoxon.as.cis.reg.by.mbd.result' %in% load('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
{
	message('Wilcoxon result loaded...')
	wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
}

if(!wilcoxon.as.cis.reg.by.mbd.result.loaded)
{
	message('create result matrix')

	wilcoxon.as.cis.reg.by.mbd.result.mat<-matrix(nrow=0,ncol=3)

	colnames(wilcoxon.as.cis.reg.by.mbd.result.mat)<-
			c('p.value','obs inv#','exp inv#') 
	
	message('fill cis result matrix')
	for (gene in genes)
	{
		#if(!gene==genes[2]) next
		#testing mode
		message(gene)
		the.gene.noodles<-grep(gene,names(as.genes.noodles.ranges))
		the.gene.junctions<-grep(gene,names(as.junction.ranges))
		ln<-length(the.gene.noodles)
		lj<-length(the.gene.junctions)
		the.gene.result.mat<-matrix(c(1,0,0),nrow=ln*lj,ncol=3,byrow=TRUE)
		colnames(the.gene.result.mat)<-c('p.value','obs inv#','exp inv#') 
		for (n in 1:ln)
		{
			is.meth<-as.logical(mbd.as.genes.noodles.coverage[the.gene.noodles[n],does.mdb.has.match])
			if(!sum(is.meth) || !sum(!is.meth)) next
			for (j in 1:lj) 	
			{
				index<-(n-1)*lj+j
				ranks<-unlist(mcols(as.junction.ranges)[the.gene.junctions[j],mbd.to.rna.match[does.mdb.has.match]])
				wilc<-wilcox.test(jitter(ranks,factor=0.001)~!(is.meth))
				if(is.na(wilc$p.value)) next
				the.gene.result.mat[index,1]<-wilc$p.value	
				the.gene.result.mat[index,2]<-wilc$statistic
				the.gene.result.mat[index,3]<-(sum(is.meth)*sum(!is.meth))/2
			}
		}
		#in expand.grid, the second var is outer (slow), so first is n (as)
		rownames(the.gene.result.mat)<-
			apply(expand.grid(names(as.junction.ranges)[the.gene.junctions],names(as.genes.noodles.ranges)[the.gene.noodles]),1,
				function(pair) paste0('as@',pair[1],'~dm@',pair[2]))
		wilcoxon.as.cis.reg.by.mbd.result.mat<-rbind(wilcoxon.as.cis.reg.by.mbd.result.mat,the.gene.result.mat)
	}
	message('converting to dataframe')
	wilcoxon.as.cis.reg.by.mbd.result<-as.data.frame(wilcoxon.as.cis.reg.by.mbd.result.mat)
	save(file='wilcoxon.as.cis.reg.by.mbd.result.Rda',list=c('wilcoxon.as.cis.reg.by.mbd.result'))

	message('done\n')
}

```

Here is the table for all cis juntion-interations that pass FDR 10%

```{r table cis fdr 10%, echo=TRUE}
fdr10.cis.res<-wilcoxon.as.cis.reg.by.mbd.result[which(p.adjust(wilcoxon.as.cis.reg.by.mbd.result$p.value,method = 'BH')<0.1),]
fdr10.cis.res
```

<!-- Trash and bricks
Let's check the DM status of these two junctions:
```{ rr DM for as.by.mbd.reliable.bonf, echo=TRUE }
#as.by.mbd.reliable.bonf.result<-wilcoxon.as.local.reg.by.mbd.result[as.by.mbd.reliable.bonf,]
#rownames(as.by.mbd.reliable.bonf.result)<-names(as.junction.ranges)[as.by.mbd.reliable.bonf]
#as.by.mbd.reliable.bonf.result

#dm.in.selfreg.reliable.report<-fisher.mbd.in.as.result[as.by.mbd.reliable.bonf,]
#rownames(dm.in.selfreg.reliable.report)<-names(as.junction.ranges)[as.by.mbd.reliable.bonf]
#dm.in.selfreg.reliable.report[,1:3]
```
Let's check the AS status of these two junctions:
```{ rr trash as for as.by.mbd.reliable.bonf, echo=TRUE }
#as.in.selfreg.reliable.report<-mcols(as.junction.ranges)[as.by.mbd.reliable.bonf,]
#rownames(as.in.selfreg.reliable.report)<-names(as.junction.ranges)[as.by.mbd.reliable.bonf]
#as.in.selfreg.reliable.report
```

Let's check the AS vs DM status of these two junctions:
```{ rr trash selfreg for as.by.mbd.reliable.bonf, echo=TRUE }
#selfreg.in.selfreg.reliable.report<-as.logical(mbd.as.junction.coverage[as.by.mbd.reliable.bonf,does.mdb.has.match])
#rownames(as.in.selfreg.reliable.report)<-paste0('meth',names(as.junction.ranges)[as.by.mbd.reliable.bonf])
#mcols(as.junction.ranges)[as.by.mbd.reliable.bonf,]
#selfreg.in.selfreg.reliable.report
```

```{ rr trash prepare wilcoxon cisregulation noodles}


genes<-unique(sapply(strsplit(names(as.junction.ranges),'.',fixed = TRUE),'[',1))
#the gene names as given by junction data, so if the names changed in new list, it will be
#named as new(old) in as.genes.noodles.ranges and the neme in genes now is old


wilcoxon.as.cis.reg.by.mbd.result.loaded<-FALSE
if ('wilcoxon.as.cis.reg.by.mbd.result' %in% ls() &&
class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
#if they are already in the space, do nothing

if(
	(! wilcoxon.as.cis.reg.by.mbd.result.loaded) && 
	file.exists('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	'wilcoxon.as.cis.reg.by.mbd.result' %in% load('wilcoxon.as.cis.reg.by.mbd.result.Rda') &&
	class(wilcoxon.as.cis.reg.by.mbd.result)=='data.frame')
{
	message('Wilcoxon result loaded...')
	wilcoxon.as.cis.reg.by.mbd.result.loaded<-TRUE
}

if(!wilcoxon.as.cis.reg.by.mbd.result.loaded)
{
	message('create result matrix')

	wilcoxon.as.cis.reg.by.mbd.result.mat<-matrix(nrow=0,ncol=3)

	colnames(wilcoxon.as.cis.reg.by.mbd.result.mat)<-
			c('p.value','obs inv#','exp inv#') 
	
	message('fill cis result matrix')
	for (gene in genes)
	{
		#if(!gene==genes[2]) next
		#testing mode
		message(gene)
		the.gene.noodles<-grep(gene,names(as.genes.noodles.ranges))
		the.gene.junctions<-grep(gene,names(as.junction.ranges))
		ln<-length(the.gene.noodles)
		lj<-length(the.gene.junctions)
		the.gene.result.mat<-matrix(c(1,0,0),nrow=ln*lj,ncol=3,byrow=TRUE)
		colnames(the.gene.result.mat)<-c('p.value','obs inv#','exp inv#') 
		for (n in 1:ln)
		{
			is.meth<-as.logical(mbd.as.genes.noodles.coverage[the.gene.noodles[n],does.mdb.has.match])
			if(!sum(is.meth) || !sum(!is.meth)) next
			for (j in 1:lj) 	
			{
				index<-(n-1)*lj+j
				ranks<-unlist(mcols(as.junction.ranges)[the.gene.junctions[j],mbd.to.rna.match[does.mdb.has.match]])
				wilc<-wilcox.test(jitter(ranks,factor=0.001)~!(is.meth))
				if(is.na(wilc$p.value)) next
				the.gene.result.mat[index,1]<-wilc$p.value	
				the.gene.result.mat[index,2]<-wilc$statistic
				the.gene.result.mat[index,3]<-(sum(is.meth)*sum(!is.meth))/2
			}
		}
		#in expand.grid, the second var is outer (slow), so first is n (as)
		rownames(the.gene.result.mat)<-
			apply(expand.grid(names(as.junction.ranges)[the.gene.junctions],names(as.genes.noodles.ranges)[the.gene.noodles]),1,
				function(pair) paste0('as@',pair[1],'~dm@',pair[2]))
		wilcoxon.as.cis.reg.by.mbd.result.mat<-rbind(wilcoxon.as.cis.reg.by.mbd.result.mat,the.gene.result.mat)
	}
	message('converting to dataframe')
	wilcoxon.as.cis.reg.by.mbd.result<-as.data.frame(wilcoxon.as.cis.reg.by.mbd.result.mat)
	save(file='wilcoxon.as.cis.reg.by.mbd.result.Rda',list=c('wilcoxon.as.cis.reg.by.mbd.result'))

	message('done\n')
}

```

Here is the table for all cis juntion-interations that pass FDR 10%

```{ rr trash table cis fdr 5%, echo=TRUE}
fdr10.cis.res<-wilcoxon.as.cis.reg.by.mbd.result[which(p.adjust(wilcoxon.as.cis.reg.by.mbd.result$p.value,method = 'BH')<0.1),]
```

-->
